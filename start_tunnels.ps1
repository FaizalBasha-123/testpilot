# start_tunnels.ps1
# Starts Cloudflare tunnels for local services and writes tunnel.md with env vars.

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

Write-Host "Starting tunnels for ai-core, sonar-scanner, and sonarqube..."

function Resolve-CloudflaredPath {
    $candidates = @(
        "cloudflared",
        "C:\Program Files\Cloudflare\Cloudflared\cloudflared.exe",
        "C:\Program Files (x86)\cloudflared\cloudflared.exe"
    )

    foreach ($candidate in $candidates) {
        try {
            $cmd = Get-Command $candidate -ErrorAction Stop
            if ($cmd -and $cmd.Source) {
                return $cmd.Source
            }
        } catch {
            # try next
        }
    }

    throw "cloudflared executable not found. Install cloudflared or add it to PATH."
}

function Start-TunnelJob {
    param(
        [Parameter(Mandatory = $true)][string]$Name,
        [Parameter(Mandatory = $true)][string]$LocalUrl,
        [Parameter(Mandatory = $true)][string]$CloudflaredPath
    )

    $logFile = Join-Path (Get-Location) ("tunnel_{0}.log" -f $Name)
    if (Test-Path $logFile) {
        Remove-Item $logFile -Force
    }

    Start-Job -Name ("tunnel_{0}" -f $Name) -ScriptBlock {
        param($ExePath, $TargetUrl, $OutFile)
        & $ExePath tunnel --url $TargetUrl *> $OutFile
    } -ArgumentList $CloudflaredPath, $LocalUrl, $logFile | Out-Null

    return $logFile
}

function Get-TunnelUrlFromLog {
    param(
        [Parameter(Mandatory = $true)][string]$LogPath
    )

    if (-not (Test-Path $LogPath)) {
        return $null
    }

    $content = Get-Content -Path $LogPath -Raw -ErrorAction SilentlyContinue
    if (-not $content) {
        return $null
    }

    $match = [regex]::Match($content, "https://[a-zA-Z0-9-]+\.trycloudflare\.com")
    if ($match.Success) {
        return $match.Value.TrimEnd("/")
    }
    return $null
}

# Service-to-local-port mapping.
$serviceMap = @(
    @{ Name = "ai_core";       LocalUrl = "http://localhost:3000" },
    @{ Name = "sonar_scanner"; LocalUrl = "http://localhost:8001" },
    @{ Name = "sonarqube";     LocalUrl = "http://localhost:9000" }
)

$cloudflared = Resolve-CloudflaredPath
Write-Host ("Using cloudflared: {0}" -f $cloudflared)

# Stop previous cloudflared and tunnel jobs to avoid stale URLs.
Get-Job -Name "tunnel_*" -ErrorAction SilentlyContinue | Stop-Job -ErrorAction SilentlyContinue
Get-Job -Name "tunnel_*" -ErrorAction SilentlyContinue | Remove-Job -Force -ErrorAction SilentlyContinue
Stop-Process -Name cloudflared -ErrorAction SilentlyContinue

$logs = @{}
foreach ($svc in $serviceMap) {
    Write-Host ("Starting tunnel {0} -> {1}" -f $svc.Name, $svc.LocalUrl)
    $logs[$svc.Name] = Start-TunnelJob -Name $svc.Name -LocalUrl $svc.LocalUrl -CloudflaredPath $cloudflared
}

# Wait for URLs to appear in logs.
$deadline = (Get-Date).AddSeconds(45)
$urls = @{}
while ((Get-Date) -lt $deadline) {
    foreach ($svc in $serviceMap) {
        if (-not $urls.ContainsKey($svc.Name)) {
            $url = Get-TunnelUrlFromLog -LogPath $logs[$svc.Name]
            if ($url) {
                $urls[$svc.Name] = $url
            }
        }
    }

    if ($urls.Count -eq $serviceMap.Count) {
        break
    }

    Start-Sleep -Milliseconds 800
}

if ($urls.Count -ne $serviceMap.Count) {
    Write-Host "Failed to fetch all tunnel URLs. Check log files:" -ForegroundColor Red
    foreach ($svc in $serviceMap) {
        Write-Host ("  {0}: {1}" -f $svc.Name, $logs[$svc.Name])
    }
    exit 1
}

$aiCoreUrl = $urls["ai_core"]
$sonarScannerUrl = $urls["sonar_scanner"]
$sonarqubeUrl = $urls["sonarqube"]

$envLines = @(
    ("AI_CORE_URL={0}" -f $aiCoreUrl),
    ("AI_REVIEW_WEBHOOK_URL={0}/api/v1/github_webhooks" -f $aiCoreUrl),
    ("SONAR_SERVICE_URL={0}" -f $sonarScannerUrl),
    ("SONARQUBE__URL={0}" -f $sonarqubeUrl),
    ("SONARQUBE_URL={0}" -f $sonarqubeUrl),
    "ENABLE_MOCK_REVIEW=false"
)

$tunnelMdPath = Join-Path (Get-Location) "tunnel.md"
$doc = @()
$doc += "# Tunnel Environment Variables"
$doc += "# Generated by start_tunnels.ps1 at $(Get-Date -Format s)"
$doc += ""
$doc += "```env"
$doc += $envLines
$doc += "```"
$doc += ""
$doc += "# Raw key=value"
$doc += $envLines

# Replace previous file content every run.
Set-Content -Path $tunnelMdPath -Value ($doc -join "`r`n")

Write-Host ""
Write-Host "Tunnels are active and tunnel.md has been replaced with fresh values." -ForegroundColor Green
Write-Host ""
foreach ($line in $envLines) {
    Write-Host $line
}
Write-Host ""
Write-Host "Log files:"
foreach ($svc in $serviceMap) {
    Write-Host ("  {0}: {1}" -f $svc.Name, $logs[$svc.Name])
}
